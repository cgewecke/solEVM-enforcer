pragma solidity ^0.5.2;
pragma experimental ABIEncoderV2;


library EVMCode {
    struct Code {
        uint length; // length is zero-based
        mapping (uint => bytes32) fragments;
        mapping (uint => bool) known;
    }

    struct RawCode {
        uint pos;
        bytes32 value;
    }

    // TODO no more external address
    // function fromAddress(address codeAddress) internal view returns (Code memory code) {
    //     code.codeAddress = codeAddress;
    //     uint codeSize;
    //     assembly {
    //         codeSize := extcodesize(codeAddress)
    //     }

    //     code.length = codeSize;
    // }

    function fromArray(RawCode[] memory codes, uint length) internal pure return (Code memory code) {
        code.length = length;
        for (uint i = 0; i < codes.length; i++) {
            code.fragments[codes[i].pos] = codes[i].value;
            code.known[codes[i].pos] = true;
        }
    }

    /**
      * @dev return the opcode at position if known. Otherwise return fe, which is invalid opcode
      *
      * @params uint pos: position of the required byte, from 0 to 31
      */
    function getOpcodeAt(Code memory self, uint pos) internal view returns (uint8 opcode) {
        uint fragmentPos = pos >> 5;

        if (code.known[pos]) {
            // 0x00000000 11111111 22222222 ... (256 bit)
            // to get a byte at position x, we need to shift all these byte at position > x + 8
            // x = 0 -> shift 248 = (32 - 1) * 8
            // x = 1 -> shift 242 = (32 - 2) * 8
            // x = 31 -> shift 0 = (32 - 32) * 8
            return uint8(code.fragments[fragmentPos] >> ((31 - pos % 32) * 8));
        }
        return 0xfe;
    }

    function toBytes(Code memory self) internal view returns (bytes memory bts) {
        // TODO no more code address
        // address codeContractAddress = self.codeAddress;

        // if (codeContractAddress == address(0)) {
        //     bts = self.codeBytes;
        // } else {
        //     uint size = self.length;
        //     assembly {
        //         bts := mload(0x40)
        //         // padding up to word size
        //         mstore(0x40, add(bts, and(add(add(size, 0x20), 0x1f), not(0x1f))))
        //         mstore(bts, size)
        //         extcodecopy(codeContractAddress, add(bts, 0x20), 0, size)
        //     }
        // }
    }

    function toUint(Code memory self, uint pos, uint numBytes) internal view returns (uint data) {
        // if pos + numBytes > self.length, we get zeroes.
        // this is the behaviour we want
        assert(32 >= numBytes && numBytes > 0);

        // TODO no more code address
        // 2 cases:
        // - return data fit in a fragment
        // - return data span 2 fragments
        uint fragmentPos = pos >> 5;
        // only need to retrieve 32 bytes
        if (fragmentPos == ((pos + numBytes) >> 5)) {
            // retrieve the word which contains the required data
            //   shift left to strip unnecessary data on the left
            uint temp = code.fragments[fragmentPos] << ((pos % 32) * 8);
            //   then shift right to strip unnecessary data on the right
            return temp >> ((32 - numBytes) * 8));
        }

        // require fetching an additional 32 bytes
        //   the left part should be the rightmost part of the first word
        //   to retrieve: shift left to strip, then shift back to correct position in numBytes
        uint left = (code.fragments[fragmentsPos] << ((pos % 32) * 8)) >> ((32 - numBytes) * 8);
        //   the right part should be the leftmost part of the second word
        //   to retrieve: shift all the way to the right
        //   64 - numBytes - (pos % 32) = 32 - (numBytes - (32 - (pos % 32))) = word_length - (required_length - (left_path_length))
        //   numBytes + (pos % 32) >= 32, if not, then it requires only 1 byte
        uint right = (code.fragments[fragmentsPos + 1] >> (64 - numBytes - (pos % 32)) * 8);

        return left | right;
    }
}
