pragma solidity ^0.5.2;
pragma experimental ABIEncoderV2;


library EVMCode {
    struct Code {
        uint length;
        uint fragLength; // length is zero-based, this is length of fragments array, not the actually length of code
        // TODO improve this
        //   we have to use memory for EVMCode, so this must be an fixed-size array, not a mapping or dynamic-size array
        // although 50 should me enough for most cases
        RawCode[50] fragments;
    }

    struct RawCode {
        uint pos;
        uint value;
    }

    function fromArray(RawCode[50] memory codes, uint fragLength, uint length) internal pure returns (Code memory code) {
        code.fragLength = fragLength;
        code.length = length;
        for (uint i = 0; i < fragLength; i++) {
            // require to submit array in ascending order
            require(i == 0 || codes[i].pos > codes[i-1].pos, "wrong code order");
            require(codes[i].pos <= (length >> 5), "incorrect code length");
            code.fragments[i] = RawCode(codes[i].pos, codes[i].value);
        }
    }

    /**
      * @dev find the position of the required word using binary search
      */
    function findFragment(Code memory self, uint wordPos) internal view returns (uint pos) {
        uint left = 0;
        uint right = self.fragLength;
        uint mid;

        while (left < right) {
            mid = (left + right) >> 1;
            if (self.fragments[mid].pos == wordPos) {
                return mid;
            }
            if (self.fragments[mid].pos > wordPos) {
                right = mid;
            } else {
                left = mid+1;
            }
        }
        return uint(-1);
    }

    /**
      * @dev return the opcode at position if known. Otherwise return fe, which is invalid opcode
      *
      */
    function getOpcodeAt(Code memory self, uint pos) internal returns (uint8 opcode) {
        uint wordPos = pos >> 5;
        uint fragmentPos = findFragment(self, wordPos);

        require(fragmentPos != uint(-1), 'Opcode missing');
        // 0x00000000 11111111 22222222 ... (256 bit)
        // to get a byte at position x, we need to shift all these byte at position > x + 8
        // x = 0 -> shift 248 = (32 - 1) * 8
        // x = 1 -> shift 242 = (32 - 2) * 8
        // x = 31 -> shift 0 = (32 - 32) * 8
        return uint8(self.fragments[fragmentPos].value >> ((31 - (pos % 32)) * 8));
    }

    /**
      * @dev return code as bytes array, from a position for a number of bytes
      *     revert if the known code cannot fulfill the requirement
      */
    function toBytes(Code memory self, uint pos, uint numBytes) internal view returns (bytes memory bts) {
        uint wordPos = pos >> 5;
        uint fragmentPos = findFragment(self, wordPos);
        require(fragmentPos != uint(-1), "Code not found");

        assembly {
            bts := mload(0x40)
            mstore(0x40, add(bts, and(add(add(numBytes, 0x20), 0x1f), not(0x1f))))
            mstore(bts, numBytes)
        }
        RawCode[50] memory fragments = self.fragments;
        uint copiedLen = 0;
        // copy first fragment, which do not fit in whole word
        if (pos % 32 != 0) {
            assembly {
                // store value at fragmentPos to bts, shift left to correct for pos
                mstore(add(bts, 0x20), shl(mul(mod(pos, 0x20), 0x08), mload(add(mload(add(fragments, mul(fragmentPos, 0x20))), 0x20))))
            }
            fragmentPos += 1;
            copiedLen += 32 - pos % 32;
        }

        // copy the rest
        while (copiedLen < numBytes) {
            require(fragmentPos == 0 ||
                    self.fragments[fragmentPos].pos == self.fragments[fragmentPos-1].pos + 1, "Known code not enough");
            assembly {
                mstore(add(bts, add(copiedLen, 0x20)), mload(add(mload(add(fragments, mul(fragmentPos, 0x20))), 0x20)))
            }
            fragmentPos += 1;
            copiedLen += 32;
        }
    }

    function toUint(Code memory self, uint pos, uint numBytes) internal view returns (uint data) {
        // if pos + numBytes > self.length, we get zeroes.
        // this is the behaviour we want
        assert(32 >= numBytes && numBytes > 0);

        // 2 cases:
        // - return data fit in a fragment
        // - return data span 2 fragments
        uint wordPos = pos >> 5;
        uint fragmentPos = findFragment(self, wordPos);
        require(fragmentPos != uint(-1), "Code not found");

        // only need to retrieve 32 bytes
        if (self.fragments[fragmentPos].pos == ((pos + numBytes - 1) >> 5)) {
            // retrieve the word which contains the required data
            //   shift left to strip unnecessary data on the left
            uint temp = self.fragments[fragmentPos].value << ((pos % 32) * 8);
            //   then shift right to strip unnecessary data on the right
            return temp >> ((32 - numBytes) * 8);
        }

        // require fetching an additional 32 bytes
        require(self.fragments[fragmentPos+1].pos == self.fragments[fragmentPos].pos + 1, "Code not enough");
        //   the left part should be the rightmost part of the first word
        //   to retrieve: shift left to strip, then shift back to correct position in numBytes
        uint left = (self.fragments[fragmentPos].value << ((pos % 32) * 8)) >> ((32 - numBytes) * 8);
        //   the right part should be the leftmost part of the second word
        //   to retrieve: shift all the way to the right
        //   64 - numBytes - (pos % 32) = 32 - (numBytes - (32 - (pos % 32))) = word_length - (required_length - (left_path_length))
        //   numBytes + (pos % 32) >= 32, if not, then it requires only 1 byte
        uint right = (self.fragments[fragmentPos + 1].value >> (64 - numBytes - (pos % 32)) * 8);

        return left | right;
    }
}
